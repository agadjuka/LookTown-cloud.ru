# Отчёт о системе хранения памяти в проекте

## Общая архитектура

Память диалогов хранится в **PostgreSQL** через репозиторий `ConversationRepository`. Система использует две основные таблицы:
- `public.conversations` - хранит информацию о диалогах
- `public.messages` - хранит все сообщения в диалогах

## Структура хранения

### Таблица conversations
- `id` (UUID) - уникальный идентификатор диалога
- `telegram_user_id` (INTEGER) - ID пользователя в Telegram
- `created_at` (TIMESTAMP) - время создания диалога

### Таблица messages
- `id` (INTEGER) - уникальный идентификатор сообщения
- `conversation_id` (UUID) - связь с диалогом
- `role` (VARCHAR) - роль отправителя: 'user', 'assistant', 'tool', 'system'
- `content` (TEXT) - содержимое сообщения
- `created_at` (TIMESTAMP) - время создания сообщения

## Как хранится память

### 1. Создание диалога
При первом обращении пользователя система:
- Ищет существующий диалог по `telegram_user_id` (берет последний по дате создания)
- Если диалог не найден, создает новый с UUID
- Метод: `ConversationRepository.get_or_create_conversation(telegram_user_id)`

**Файл:** `src/storage/conversation_repo.py:17-53`

### 2. Сохранение сообщений
Каждое сообщение сохраняется в таблицу `messages` с указанием:
- `conversation_id` - к какому диалогу относится
- `role` - роль отправителя (user/assistant/tool/system)
- `content` - текст сообщения
- `created_at` - автоматически устанавливается как NOW()

**Метод:** `ConversationRepository.append_message(conversation_id, role, content)`

**Файл:** `src/storage/conversation_repo.py:55-95`

## Как обновляется память

### Процесс обработки сообщения:

1. **Сохранение входящего сообщения пользователя**
   - Сообщение дополняется московским временем: `[Текущее время: YYYY-MM-DD HH:MM] {текст}`
   - Сохраняется с ролью `"user"`
   - **Файл:** `src/services/agent_service.py:117-123`

2. **Загрузка истории для контекста**
   - Загружаются последние 30 сообщений из диалога
   - История передается в граф LangGraph для контекста
   - **Файл:** `src/services/agent_service.py:125-130`

3. **Обработка через граф**
   - Граф обрабатывает сообщение с учетом истории
   - Агенты используют историю для понимания контекста

4. **Сохранение ответа ассистента**
   - После получения ответа от агента, он сохраняется с ролью `"assistant"`
   - **Файл:** `src/services/agent_service.py:156-163`

5. **Сохранение информации о tool-вызовах**
   - Если использовались инструменты, сохраняется системное сообщение: `"Tools used: {список инструментов}"`
   - Роль: `"system"`
   - **Файл:** `src/services/agent_service.py:165-175`

## Как подгружается память

### Загрузка истории сообщений

При каждом новом сообщении:
1. Определяется `conversation_id` для пользователя
2. Загружаются последние 30 сообщений методом `load_last_messages(conversation_id, limit=30)`
3. Сообщения сортируются в хронологическом порядке (по `created_at ASC, id ASC`)
4. История передается в состояние графа `ConversationState.history`

**Метод:** `ConversationRepository.load_last_messages(conversation_id, limit=30)`

**Файл:** `src/storage/conversation_repo.py:97-138`

**Использование:** `src/services/agent_service.py:125-132`

### Формат загружаемой истории

История возвращается в формате списка словарей:
```python
[
    {"role": "user", "content": "..."},
    {"role": "assistant", "content": "..."},
    {"role": "system", "content": "Tools used: ..."},
    ...
]
```

### Использование истории в графе

История передается в начальное состояние графа:
- Поле `history` в `ConversationState`
- Агенты получают историю через параметр `history` в методах обработки
- История используется для контекста при генерации ответов

**Файл:** `src/services/agent_service.py:134-144`

## Как стирается память

### 1. Команда /new (создание нового диалога)

При вызове команды `/new`:
1. Находятся все старые диалоги пользователя
2. Удаляются все сообщения из старых диалогов
3. Удаляются сами старые диалоги
4. Создается новый диалог с новым UUID
5. Очищается история результатов инструментов (ToolHistoryService)

**Метод:** `ConversationRepository.create_new_conversation(telegram_user_id)`

**Файл:** `src/storage/conversation_repo.py:140-176`

**Использование:** `src/services/agent_service.py:199-230`

### 2. Очистка сообщений диалога (альтернативный метод)

Можно очистить только сообщения, не удаляя сам диалог:
- Удаляются все записи из таблицы `messages` для указанного `conversation_id`
- Сам диалог остается в базе

**Метод:** `ConversationRepository.clear_conversation_messages(conversation_id)`

**Файл:** `src/storage/conversation_repo.py:178-191`

## Подключение к базе данных

### PostgreSQL Client

Используется пул соединений (`ThreadedConnectionPool`):
- Минимум соединений: 1
- Максимум соединений: 10
- Параметры подключения берутся из переменных окружения:
  - `PG_HOST` (по умолчанию: "localhost")
  - `PG_PORT` (по умолчанию: "5432")
  - `PG_DB` (по умолчанию: "ai_db")
  - `PG_USER` (по умолчанию: "postgres")
  - `PG_PASSWORD`
  - Или `DATABASE_URL` (полная строка подключения)

**Файл:** `src/storage/pg_client.py`

### Глобальный экземпляр репозитория

Репозиторий создается как singleton через функцию `get_conversation_repo()`:
- Один экземпляр на все приложение
- Ленивая инициализация при первом обращении

**Файл:** `src/storage/conversation_repo.py:216-225`

## Особенности реализации

### 1. Добавление времени к сообщениям пользователя

Все входящие сообщения пользователя дополняются московским временем в формате:
```
[Текущее время: YYYY-MM-DD HH:MM] {текст сообщения}
```

Это помогает агенту понимать временной контекст диалога.

**Файл:** `src/services/agent_service.py:113-115`

### 2. Ограничение истории

Загружаются только последние 30 сообщений для оптимизации:
- Уменьшает размер контекста для LLM
- Ускоряет загрузку из базы
- Сохраняет релевантность контекста

**Параметр:** `limit=30` в `load_last_messages()`

### 3. Хранение информации о tool-вызовах

Информация о использованных инструментах сохраняется как системные сообщения:
- Формат: `"Tools used: {tool1}, {tool2}, ..."`
- Роль: `"system"`
- Помогает отслеживать, какие инструменты использовались в диалоге

### 4. Асинхронная работа

Все операции с базой данных выполняются асинхронно через `asyncio.to_thread()`:
- Не блокирует основной поток
- Позволяет обрабатывать несколько запросов параллельно

**Пример:** `src/services/agent_service.py:108-111, 118-123, 126-130, 158-163`

## Схема работы памяти в цикле обработки сообщения

```
1. Пользователь отправляет сообщение
   ↓
2. Определяется/создается conversation_id
   ↓
3. Сообщение сохраняется в БД (role: "user")
   ↓
4. Загружаются последние 30 сообщений из истории
   ↓
5. История передается в граф LangGraph
   ↓
6. Граф обрабатывает сообщение с учетом истории
   ↓
7. Ответ ассистента сохраняется в БД (role: "assistant")
   ↓
8. Информация о tool-вызовах сохраняется (role: "system")
   ↓
9. Ответ отправляется пользователю
```

## Файлы, отвечающие за память

1. **`src/storage/conversation_repo.py`** - репозиторий для работы с диалогами и сообщениями
2. **`src/storage/pg_client.py`** - клиент для подключения к PostgreSQL
3. **`src/graph/conversation_state.py`** - определение структуры состояния с полем `history`
4. **`src/services/agent_service.py`** - сервис, который использует репозиторий для сохранения/загрузки памяти
5. **`src/graph/main_graph.py`** - граф, который получает историю в состоянии

## Резюме

Память в проекте:
- **Хранится** в PostgreSQL в таблицах `conversations` и `messages`
- **Обновляется** при каждом сообщении: сохраняются сообщения пользователя, ответы ассистента и информация о tool-вызовах
- **Подгружается** при каждом новом сообщении (последние 30 сообщений)
- **Стирается** при команде `/new` (удаляются все старые диалоги и сообщения, создается новый диалог)

Система обеспечивает персистентную память между сессиями и позволяет боту помнить контекст предыдущих сообщений в диалоге.






